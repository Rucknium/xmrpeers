% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/peer-selection.R
\name{gen.network}
\alias{gen.network}
\title{Generate a simulated Monero network}
\usage{
gen.network(
  outbound.ips,
  malicious.ips = NULL,
  n.unreachable = 0,
  already.connected.subnet.level = 16,
  deduplication.subnet.level = 24,
  do.deduplication = TRUE,
  default.outbound.connections = 12,
  dropped.connection.churns = 12,
  compute.network.stats = TRUE
)
}
\arguments{
\item{outbound.ips}{A character vector of IP addresses that host reachable
Monero nodes. Required.}

\item{malicious.ips}{Optional character vector of IP addresses that are suspected
to be malicious. Can contain IP address ranges with subnet notation.}

\item{n.unreachable}{Number of unreachable nodes assumed to be in the
network.}

\item{already.connected.subnet.level}{The subnet mask level of the
"already-connected-subnet" disqualifying condition. Set to 32 to disable
this disqualifying condition.}

\item{deduplication.subnet.level}{The subnet mask level at which to perform
subnet deduplication.}

\item{do.deduplication}{If TRUE, perform subnet deduplication. If FALSE,
do not.}

\item{default.outbound.connections}{The number of outbound connections
of each node.}

\item{dropped.connection.churns}{After \code{default.outbound.connections}
has been reached, the number of times to drop one connection and add
another one. The "already-connected-subnet" behavior makes some peer
churning necessary to get the correct probability distribution.}

\item{compute.network.stats}{If TRUE, compute network summary statistics
of the simulated network.}
}
\value{
A list with three elements:
\describe{
\item{nodes}{A \code{data.table} with seven columns: \code{index}, an index of the
node. \code{ip}, the IP address of the node, if it is reachable (NA if it
is not). \code{already.connected.subnet}, the subnet that the node belongs to,
based on the \code{already.connected.subnet.level} argument specified by the
user. \code{deduplication.subnet}, the subnet that the node belongs to,
based on the \code{deduplication.subnet.level} argument specified by the user.
\code{reachable}, TRUE if reachable and FALSE if not. \code{malicious}, TRUE if
node is on the \code{malicious.ips} list supplied by the user. \code{n.inbound},
number of inbound connections of the node in the simulated network.
\code{n.malicious.outbound}, the number of outbound connections to nodes
on the \code{malicious.ips} list.}
\item{edgelist}{A \code{data.table}. The network edge list of the directed
graph. The \code{origin} column is the node establishing the connection.
The \code{destination} column is the node accepting the connection. The
\code{index} column of the \code{nodes} \code{data.table} is used as the identifier.}
\item{network.stats}{A list of four network summary statistics, computed
by the \code{igraph} package: \code{centr_betw}, \code{centr_clo}, \code{centr_degree},
and \code{centr_eigen}. See their documentation in the \code{igraph} package
for interpretation.}
}
}
\description{
Generates a simulated Monero network based on user-provided
IP addresses of reachable nodes. The assumed number of unreachable nodes
can be provided. A list of malicious node IP addresses can specify nodes
that do not establish outbound connections. The user can specify whether
the peer selection algorithm should perform subnet deduplication, and
at what subnet mask level. Network summary statistics are optionally
computed.
}
\examples{
\dontrun{
data(good_peers)

good_peers <- stringr::str_extract(good_peers,
  "[0-9]{1,3}[.][0-9]{1,3}[.][0-9]{1,3}[.][0-9]{1,3}")
good_peers <- unique(good_peers)
good_peers <- na.omit(good_peers)
# Clean IP addresses

suspected.malicious.ips <- readLines(
  "https://raw.githubusercontent.com/Boog900/monero-ban-list/refs/heads/main/ban_list.txt")

future::plan(future::multisession,
  workers = max(c(1, floor(parallelly::availableCores()/6))))
# Multi-threaded is recommended

share.reachable <- 0.2
# Set share of nodes that are reachable to 20 percent

n.assumed.unreachable <- floor(length(good_peers) *
    ((1 - share.reachable) / share.reachable))

set.seed(314)
# This is a random simulation

generated.network <- gen.network(outbound.ips = good_peers,
  malicious.ips = suspected.malicious.ips,
  n.unreachable = n.assumed.unreachable)

hist(generated.network$nodes[
  reachable == TRUE & malicious == FALSE, n.inbound], breaks = 50)

# Network stats
sapply(names(generated.network$network.stats), function(x) {
  generated.network$network.stats[[x]]$centralization
})
}
}
